use clap::{Arg, ArgAction, Command};
use crate::cli_styles::get_styles;

pub fn julia_cli() -> Command {
    Command::new("julia")
        .about("The Julia Programming Language")
        .version("1.11.0") // This is a placeholder version
        .styles(get_styles())
        .arg(
            Arg::new("channel")
                .help("Select a Julia channel/version")
                .long_help("Select a Julia channel/version (e.g., +release, +lts, +1.10)")
                .value_name("CHANNEL")
                .action(ArgAction::Set)
                .value_parser(clap::value_parser!(String))
                .hide(true) // Hide from help since it's parsed specially with + prefix
        )
        .arg(
            Arg::new("version")
                .short('v')
                .long("version")
                .help("Display version information")
                .action(ArgAction::SetTrue)
        )
        .arg(
            Arg::new("help")
                .short('h')
                .long("help")
                .help("Print command-line options (this message)")
                .action(ArgAction::SetTrue)
        )
        .arg(
            Arg::new("help-hidden")
                .long("help-hidden")
                .help("Print uncommon options not shown by `-h`")
                .action(ArgAction::SetTrue)
        )
        .arg(
            Arg::new("project")
                .long("project")
                .value_name("DIR|@.|@script|@temp")
                .help("Set <dir> as the active project/environment")
                .long_help("Set <dir> as the active project/environment. Or, create a temporary environment with `@temp`. The default @. option will search through parent directories until a Project.toml or JuliaProject.toml file is found. @script is similar, but searches up from the programfile or a path relative to programfile.")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("sysimage")
                .short('J')
                .long("sysimage")
                .value_name("FILE")
                .help("Start up with the given system image file")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("home")
                .short('H')
                .long("home")
                .value_name("DIR")
                .help("Set location of `julia` executable")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("startup-file")
                .long("startup-file")
                .value_name("yes|no")
                .help("Load `JULIA_DEPOT_PATH/config/startup.jl`")
                .action(ArgAction::Set)
                .value_parser(["yes", "no"])
        )
        .arg(
            Arg::new("handle-signals")
                .long("handle-signals")
                .value_name("yes|no")
                .help("Enable or disable Julia's default signal handlers")
                .action(ArgAction::Set)
                .value_parser(["yes", "no"])
        )
        .arg(
            Arg::new("sysimage-native-code")
                .long("sysimage-native-code")
                .value_name("yes|no")
                .help("Use native code from system image if available")
                .action(ArgAction::Set)
                .value_parser(["yes", "no"])
        )
        .arg(
            Arg::new("compiled-modules")
                .long("compiled-modules")
                .value_name("yes|no|existing|strict")
                .help("Enable or disable incremental precompilation of modules")
                .long_help("Enable or disable incremental precompilation of modules. The `existing` option allows use of existing compiled modules that were previously precompiled, but disallows creation of new precompile files. The `strict` option is similar, but will error if no precompile file is found.")
                .action(ArgAction::Set)
                .value_parser(["yes", "no", "existing", "strict"])
        )
        .arg(
            Arg::new("pkgimages")
                .long("pkgimages")
                .value_name("yes|no|existing")
                .help("Enable or disable usage of native code caching in the form of pkgimages")
                .long_help("Enable or disable usage of native code caching in the form of pkgimages. The `existing` option allows use of existing pkgimages but disallows creation of new ones")
                .action(ArgAction::Set)
                .value_parser(["yes", "no", "existing"])
        )
        .arg(
            Arg::new("eval")
                .short('e')
                .long("eval")
                .value_name("EXPR")
                .help("Evaluate <expr>")
                .action(ArgAction::Set)
                .allow_hyphen_values(true)
        )
        .arg(
            Arg::new("print")
                .short('E')
                .long("print")
                .value_name("EXPR")
                .help("Evaluate <expr> and display the result")
                .action(ArgAction::Set)
                .allow_hyphen_values(true)
        )
        .arg(
            Arg::new("load")
                .short('L')
                .long("load")
                .value_name("FILE")
                .help("Load <file> immediately on all processors")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("threads")
                .short('t')
                .long("threads")
                .value_name("auto|N[,auto|M]")
                .help("Enable N[+M] threads")
                .long_help("Enable N[+M] threads; N threads are assigned to the `default` threadpool, and if M is specified, M threads are assigned to the `interactive` threadpool; `auto` tries to infer a useful default number of threads to use")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("gcthreads")
                .long("gcthreads")
                .value_name("N[,M]")
                .help("Use N threads for GC mark phase and M threads for concurrent sweep")
                .long_help("Use N threads for the mark phase of GC and M (0 or 1) threads for the concurrent sweeping phase of GC. N is set to half of the number of compute threads and M is set to 0 if unspecified.")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("procs")
                .short('p')
                .long("procs")
                .value_name("N|auto")
                .help("Integer value N launches N additional local worker processes")
                .long_help("Integer value N launches N additional local worker processes. `auto` launches as many workers as the number of local CPU threads (logical cores)")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("machine-file")
                .long("machine-file")
                .value_name("FILE")
                .help("Run processes on hosts listed in <file>")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("interactive")
                .short('i')
                .long("interactive")
                .help("Interactive mode; REPL runs and `isinteractive()` is true")
                .action(ArgAction::SetTrue)
        )
        .arg(
            Arg::new("quiet")
                .short('q')
                .long("quiet")
                .help("Quiet startup: no banner, suppress REPL warnings")
                .action(ArgAction::SetTrue)
        )
        .arg(
            Arg::new("banner")
                .long("banner")
                .value_name("yes|no|short|auto")
                .help("Enable or disable startup banner")
                .action(ArgAction::Set)
                .value_parser(["yes", "no", "short", "auto"])
        )
        .arg(
            Arg::new("color")
                .long("color")
                .value_name("yes|no|auto")
                .help("Enable or disable color text")
                .action(ArgAction::Set)
                .value_parser(["yes", "no", "auto"])
        )
        .arg(
            Arg::new("history-file")
                .long("history-file")
                .value_name("yes|no")
                .help("Load or save history")
                .action(ArgAction::Set)
                .value_parser(["yes", "no"])
        )
        .arg(
            Arg::new("depwarn")
                .long("depwarn")
                .value_name("yes|no|error")
                .help("Enable or disable syntax and method deprecation warnings")
                .long_help("Enable or disable syntax and method deprecation warnings (`error` turns warnings into errors)")
                .action(ArgAction::Set)
                .value_parser(["yes", "no", "error"])
        )
        .arg(
            Arg::new("warn-overwrite")
                .long("warn-overwrite")
                .value_name("yes|no")
                .help("Enable or disable method overwrite warnings")
                .action(ArgAction::Set)
                .value_parser(["yes", "no"])
        )
        .arg(
            Arg::new("warn-scope")
                .long("warn-scope")
                .value_name("yes|no")
                .help("Enable or disable warning for ambiguous top-level scope")
                .action(ArgAction::Set)
                .value_parser(["yes", "no"])
        )
        .arg(
            Arg::new("cpu-target")
                .short('C')
                .long("cpu-target")
                .value_name("TARGET")
                .help("Limit usage of CPU features up to <target>")
                .long_help("Limit usage of CPU features up to <target>; set to `help` to see the available options")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("optimize")
                .short('O')
                .long("optimize")
                .value_name("0|1|2|3")
                .help("Set the optimization level")
                .long_help("Set the optimization level (level 3 if `-O` is used without a level)")
                .action(ArgAction::Set)
                .num_args(0..=1)
                .default_missing_value("3")
                .value_parser(["0", "1", "2", "3"])
        )
        .arg(
            Arg::new("min-optlevel")
                .long("min-optlevel")
                .value_name("0|1|2|3")
                .help("Set a lower bound on the optimization level")
                .action(ArgAction::Set)
                .value_parser(["0", "1", "2", "3"])
        )
        .arg(
            Arg::new("debug-info")
                .short('g')
                .long("debug-info")
                .value_name("0|1|2")
                .help("Set the level of debug info generation")
                .long_help("Set the level of debug info generation (level 2 if `-g` is used without a level)")
                .action(ArgAction::Set)
                .num_args(0..=1)
                .default_missing_value("2")
                .value_parser(["0", "1", "2"])
        )
        .arg(
            Arg::new("inline")
                .long("inline")
                .value_name("yes|no")
                .help("Control whether inlining is permitted")
                .long_help("Control whether inlining is permitted, including overriding @inline declarations")
                .action(ArgAction::Set)
                .value_parser(["yes", "no"])
        )
        .arg(
            Arg::new("check-bounds")
                .long("check-bounds")
                .value_name("yes|no|auto")
                .help("Emit bounds checks always, never, or respect @inbounds declarations")
                .action(ArgAction::Set)
                .value_parser(["yes", "no", "auto"])
        )
        .arg(
            Arg::new("math-mode")
                .long("math-mode")
                .value_name("ieee|user")
                .help("Always follow `ieee` floating point semantics or respect `@fastmath` declarations")
                .action(ArgAction::Set)
                .value_parser(["ieee", "user"])
        )
        .arg(
            Arg::new("code-coverage")
                .long("code-coverage")
                .value_name("none|user|all|@<path>|tracefile.info")
                .help("Count executions of source lines")
                .long_help("Count executions of source lines (omitting setting is equivalent to `user`). Use @<path> to count only in files under the given path/directory. Use tracefile.info to append coverage to an LCOV tracefile")
                .action(ArgAction::Set)
                .num_args(0..=1)
                .default_missing_value("user")
        )
        .arg(
            Arg::new("track-allocation")
                .long("track-allocation")
                .value_name("none|user|all|@<path>")
                .help("Count bytes allocated by each source line")
                .long_help("Count bytes allocated by each source line (omitting setting is equivalent to `user`). Use @<path> to count only in files under the given path/directory")
                .action(ArgAction::Set)
                .num_args(0..=1)
                .default_missing_value("user")
        )
        .arg(
            Arg::new("bug-report")
                .long("bug-report")
                .value_name("KIND")
                .help("Launch a bug report session")
                .long_help("Launch a bug report session. It can be used to start a REPL, run a script, or evaluate expressions. For more information, see --bug-report=help")
                .action(ArgAction::Set)
        )
        .arg(
            Arg::new("heap-size-hint")
                .long("heap-size-hint")
                .value_name("SIZE")
                .help("Forces garbage collection if memory usage is higher than the given value")
                .long_help("Forces garbage collection if memory usage is higher than the given value. The value may be specified as a number of bytes, optionally in units of KB, MB, GB, or TB, or as a percentage of physical memory with %")
                .action(ArgAction::Set)
        )
        // Hidden options
        .arg(
            Arg::new("compile")
                .long("compile")
                .value_name("yes|no|all|min")
                .help("Enable or disable JIT compiler, or request exhaustive or minimal compilation")
                .action(ArgAction::Set)
                .value_parser(["yes", "no", "all", "min"])
                .hide(true)
        )
        .arg(
            Arg::new("output-o")
                .long("output-o")
                .value_name("NAME")
                .help("Generate an object file (including system image data)")
                .action(ArgAction::Set)
                .hide(true)
        )
        .arg(
            Arg::new("output-ji")
                .long("output-ji")
                .value_name("NAME")
                .help("Generate a system image data file (.ji)")
                .action(ArgAction::Set)
                .hide(true)
        )
        .arg(
            Arg::new("strip-metadata")
                .long("strip-metadata")
                .help("Remove docstrings and source location info from system image")
                .action(ArgAction::SetTrue)
                .hide(true)
        )
        .arg(
            Arg::new("strip-ir")
                .long("strip-ir")
                .help("Remove IR (intermediate representation) of compiled functions")
                .action(ArgAction::SetTrue)
                .hide(true)
        )
        .arg(
            Arg::new("output-unopt-bc")
                .long("output-unopt-bc")
                .value_name("NAME")
                .help("Generate unoptimized LLVM bitcode (.bc)")
                .action(ArgAction::Set)
                .hide(true)
        )
        .arg(
            Arg::new("output-bc")
                .long("output-bc")
                .value_name("NAME")
                .help("Generate LLVM bitcode (.bc)")
                .action(ArgAction::Set)
                .hide(true)
        )
        .arg(
            Arg::new("output-asm")
                .long("output-asm")
                .value_name("NAME")
                .help("Generate an assembly file (.s)")
                .action(ArgAction::Set)
                .hide(true)
        )
        .arg(
            Arg::new("output-incremental")
                .long("output-incremental")
                .value_name("yes|no")
                .help("Generate an incremental output file (rather than complete)")
                .action(ArgAction::Set)
                .value_parser(["yes", "no"])
                .hide(true)
        )
        .arg(
            Arg::new("trace-compile")
                .long("trace-compile")
                .value_name("stderr|name")
                .help("Print precompile statements for methods compiled during execution or save to a path")
                .action(ArgAction::Set)
                .hide(true)
        )
        .arg(
            Arg::new("image-codegen")
                .long("image-codegen")
                .help("Force generate code in imaging mode")
                .action(ArgAction::SetTrue)
                .hide(true)
        )
        .arg(
            Arg::new("permalloc-pkgimg")
                .long("permalloc-pkgimg")
                .value_name("yes|no")
                .help("Copy the data section of package images into memory")
                .action(ArgAction::Set)
                .value_parser(["yes", "no"])
                .hide(true)
        )
        .arg(
            Arg::new("programfile")
                .help("Julia script to execute")
                .action(ArgAction::Set)
                .index(1)
        )
        .arg(
            Arg::new("args")
                .help("Arguments to pass to the Julia script")
                .action(ArgAction::Append)
                .index(2)
                .trailing_var_arg(true)
                .allow_hyphen_values(true)
        )
        .after_help("Use '--' to separate Julia arguments from script arguments")
}
